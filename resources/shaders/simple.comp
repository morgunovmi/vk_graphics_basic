#version 430

layout( local_size_x = 32, local_size_y = 32 ) in;

layout( binding = 0, rgba8 ) uniform readonly image2D rawImage;
layout( binding = 1, rgba8 ) uniform writeonly image2D filteredImage;

const int kernelSize = 21;
const int kernelRadius = kernelSize / 2;

layout( push_constant ) uniform params {
  float gaussCoeffs[kernelSize];
} PushConst;

const int GROUP_SIZE = 32;
const int CACHE_SIZE = GROUP_SIZE + 2 * kernelRadius;
const int LOAD_PER_THREAD = (CACHE_SIZE + GROUP_SIZE - 1) / GROUP_SIZE;

shared vec3 localCache[CACHE_SIZE][CACHE_SIZE];

void main() 
{
    ivec2 id = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imgSize = imageSize(rawImage);

    ivec2 workgroupOrigin = ivec2(gl_WorkGroupID.xy) * GROUP_SIZE - ivec2(kernelRadius, kernelRadius);

    // Load local image patch into shared memory
    for (int i = 0; i < LOAD_PER_THREAD; ++i)
    {
      for (int j = 0; j < LOAD_PER_THREAD; ++j)
      {
        ivec2 localOffset = ivec2(gl_LocalInvocationID.xy) * LOAD_PER_THREAD + ivec2(i, j);
        ivec2 globalCoords = workgroupOrigin + localOffset;

        if (localOffset.x < CACHE_SIZE && localOffset.y < CACHE_SIZE)
        {
          localCache[localOffset.x][localOffset.y] = (globalCoords.x >= 0 && globalCoords.y >= 0
              && globalCoords.x < imgSize.x && globalCoords.y < imgSize.y) ? imageLoad(rawImage, globalCoords).rgb : vec3(0.0);
        }
      }
    }
    barrier();

    if (id.x < imgSize.x && id.y < imgSize.y)
    {
      // Horizontal pass
      vec3 sum = vec3(0.0);
      for (int i = 0; i < kernelSize; ++i)
      {
        int offset = i - kernelRadius;
        sum += localCache[gl_LocalInvocationID.x + offset + kernelRadius][gl_LocalInvocationID.y + kernelRadius]
               * PushConst.gaussCoeffs[i];
      }
      barrier();

      localCache[gl_LocalInvocationID.x + kernelRadius][gl_LocalInvocationID.y + kernelRadius] = sum;

      // Vertical pass
      sum = vec3(0.0);
      for (int j = 0; j < kernelSize; ++j)
      {
        int offset = j - kernelRadius;
        sum += localCache[gl_LocalInvocationID.x + kernelRadius][gl_LocalInvocationID.y + offset + kernelRadius]
               * PushConst.gaussCoeffs[j];
      }
      barrier();

      imageStore(filteredImage, id, vec4(sum, 1.0));
    }
}